#include <stdio.h>
#include <stdlib.h>
/*
ESTE PROGRAMA IMPLEMENTA A ESTRUTURA DE DADOS FILA.

A FILA SEGUE A REGRA FIFO (FIRST IN, FIRST OUT), OU SEJA, O PRIMEIRO ELEMENTO INSERIDO
SERÁ O PRIMEIRO A SER REMOVIDO.

A MANIPULAÇÃO DA FILA SE DARÁ APENAS EM SUAS EXTREMIDADES: OS NOVOS ELEMENTOS SERÃO INSERIDOS AO FINAL DA FILA,
E A REMOÇÃO DEVERÁ SER NO PRIMEIRO ELEMENTO DA FILA

NO PROGRAMA ABAIXO SAO IMPLEMENTADAS AS TAREFAS DE:

--> CRIAR UMA FILA
--> INSERIR ELEMENTOS EM UMA FILA
--> REMOVER ELEMENTOS EM UMA FILA
--> VERIFICAR SE A FILA ESTÁ VAZIA
--> VERIFICAR A QUANTIDADE DE ELEMENTOS DA FILA
--> IMPRIMIR A FILA
--> LIBERAR O ESPAÇO DE MEMÓRIA ALOCADA PARA FILA E SEUS ELEMENTOS

*/

//ESTRUTURA QUE ARMAZENARA OS DADOS DO ALUNO
struct aluno
{
    char nome[31];
    int mat;
    float n1, n2;
};

//ESTRUTURA QUE RECEBERÁ O CONJUNTO DE DADOS DO ALUNO E O ENDEREÇO DO PROXIMO ELEMENTO DA FILA (O ALUNO A SEGUIR)
typedef struct elemento
{
    struct aluno dados;//AQUI, SERÁ ARMAZENADOS OS DADOS DO ALUNO
    struct elemento *prox;//ESTE CAMPO SERÁ UM PONTEIRO PARA O PRÓXIMO ELEMENTO DA FILA (QUE TAMBÉM SERÁ DO "TIPO" STRUCT ELEMENTO)
} Elem;

//A ESTRUTURA ABAIXO TERÁ OS APONTADORES DO NÓ DA MINHA FILA
typedef struct fila
{
    struct elemento *inicio; //ESTRUTURA QUE RECEBERÁ O PRIMEIRO ELEMENTO (DADOS DO ALUNO E PROXIMO ELEMENTO) DA FILA
    struct elemento *fim; // ESTRUTURA QUE RECEBERÁ O ULTIMO ELEMENTO DA FILA
} Fila;

//FUNÇÃO QUE RETORNA O ENDEREÇO DE MEMÓRIA DE UMA FILA VAZIA.
Fila* criar()  //CRIA UMA FUNÇÃO DO TIPO STRUCT FILA
{
    Fila* fi = (Fila*) malloc(sizeof(Fila)); //ALOCA O ESPAÇO NA MEMÓRIA
    if(fi != NULL) //SE O SISTEMA OPERACIONAL ALOCAR, ENTRA NO IF.
    {
        fi->inicio= NULL; //INICIA A POSIÇÃO INICIAL COM NULL
        fi->fim= NULL;//INICIA A POSIÇÃO FINAL COM NULL
    }
    return fi;//RETORNA O ENDEREÇO DA FILA
}

//FUNÇÃO QUE DESALOCA O ESPAÇO NA MEMÓRIA DO S.O.
void liberar(Fila *fi)
{
    if(fi !=NULL)
    {
        Elem * no;//CRIA UM PONTEIRO DE UMA ESTRUTURA ELEMENTO, PARA SERVIR DE AUXILIAR PARA O PROCESSO DE LIBERAÇÃO
        while(fi->inicio!=NULL) //VERIFICA SE A POSIÇÃO INICIA TEM ALGUMA ESTRUTURA. CASO TENHA, ENTRA NO IF
        {
            no = fi->inicio;//A ESTRUTURA AUXLIAR RECEBE O ENDEREÇO DO PRIMEIRO ELEMENTO DA MINHA FILA.
            fi->inicio = fi->inicio->prox;//A POSIÇÃO DE INICIO DA MINHA FILA PASSA A APONTAR AO VALOR QUE ESTAVA NO CAMPO PROXÍMO (APONTARÁ AO SEGUNO ELEMENTO)
            free(no);//COM A POSIÇÃO INICIAL APONTANDO PARA SEGUNDA POSIÇÃO, A PRIMEIRA (QUE ESTAVA GUARDADA NO ELEMENTO AUXILIAR) SERÁ LIBERADA.
        }//SE A POSIÇÃO DE INICIO APONTAR PARA NULL, SIGINIFICA QUE NAO HÁ MAIS ELEMENTOS NA MINHA FILA.
        free(fi);//O ESPAÇO DE MEMÓRIA ALOCADO PARA MINHA FILA É LIBERADO.
    }
}

//FUNÇÃO ABAIXO RETORNA UM INTEIRO COM A QUANTIDADE DE ELEMENTOS DA MINHA FILA
int tamanho(Fila *fi)
{
    if(fi==NULL)
    {
        return -1;//CASO MINHA FILA NAO TENHA SIDO ALOCADA NA MEMÓRIA, MINHA FUNÇÃO RETORNARÁ O VALOR -1
    }
    int cont=0;//VARIAVEL QUE CONTARÁ A QUANTIDADE DE ELEMENTOS
    Elem *no = fi->inicio;//CRIA UM ELEMENTO AUXILIAR PARA PERCORRER MINHA FILA. DESTA FORMA, CADA PASSO DADO PELO ELEMENTO AXULIAR SERÁ UM ELEMENTO DA MINHA FILA
    while(no != NULL) //ENQUANTO O ELEMENTO AUXILIAR NAO APONTAR PARA NULL,
    {
        cont++;//INCREMENTA A MINHA FILA (SE ELE ENTROU NO WHILE NA PRIMEIRA INTERAÇÃO, SIGNIFICA QUE HÁ PELO MENOS UM ELEMENTO DA FILA
        no= no->prox;//NESTE MOMENTO, NÓ RECEBERA O ENDEREÇO QUE ESTÁ NO CAMPO PRÓXIMO.
    }//SE ELE FOR IGUAL A NULL. TERMINA O LAÇO. SE NAO, SERÁ CONTABILIZADO UM NOVO ELEMENTO.
    return cont;//FUNÇÃO RETORNA A QUANTIRADE DE ELEMENTOS
}

//FUNÇÃO QUE VERIFICA SE FILA ESTÁ VAZIA OU NAO
void vazia(Fila *fi)
{
    int tam = tamanho(fi);//ESTA PARTE PODE SER CONSIDERADA OPCIONAL. APENAS APRESENTARÁ A QUANTIDADE DE ELEMENTOS DA MINHA FILA (FUNÇÃO TAMANHO)
    if(fi !=NULL)  //SE A FILA FOR ALOCADO...
    {
        if(fi->inicio==NULL)  //VERIFICA SE O CAMPO INICIO APONTA PARA NULL. CASO APONTO, A FILA ESTARÁ VAZIA.
        {
            printf("\nFILA VAZIA\n");
        }
        else    //SE NAO APONTAR, PARA NULL, TERÁ ELEMENTOS...
        {
            printf("\nFILA NAO VAZIA\n");
        }
        printf("\nFILA COM %d ELEMENTO(S)\n",tam);//APRESENTA A QUANTIDADE DE ELEMENTOS
    }
    else    //CASO MINHA FILA NAO TENHA SIDO ALOCADA...
    {
        printf("\nERRO DE ALOCACAO\n");
    }
}

//FUNÇÃO QUE IRÁ INSERIR UM NOVO ELEMENTO NA MINHA FILA
void inserir(Fila *fi, struct aluno al) //COMO PARÂMETROS DA FUNÇÃO, TEREMOS: O ENDEREÇO DA FILA ; E OS DADOS DO ALUNO (QUE SERÃO ARMAZENADOS NA MINHA STRUCT ALUNO)
{
    if(fi==NULL) //CASO A FILA NAO TENHA SIDO ALOCADA...
    {
        printf("\nERRO DE ALOCACAO\n");
    }
    else  //FILA ALOCADA
    {
        Elem *no = (Elem*) malloc(sizeof(Elem));//NESTE PASSO, SERÁ CRIADO UM NOVO ELEMENTO VAZIO (CRIADO APENAS O ESPAÇO NA MEMÓRIA)
        if(no != NULL) //CASO A ALOCAÇÃO DESTE NOVO ELEMENTO TENHA SIDO FEITA
        {
            no->dados= al;//O CAMPO DADOS, DA MINHA ESTRUTURA ELEMENTO RECEBE OS DADOS DO ALUNO PASSADO POR PARÂMETRO DA FUNÇÃO
            no->prox= NULL;//COMO ESTE ELEMENTO SERÁ INSERIDO NA ÚLTIMA POSIÇÃO, O PRÓXIMO DESTE ELEMENTO APONTARÁ PARA NULL
            //NO IF ABAIXO, TEREMOS AS DUAS POSSIBILIDADES DE INSERIR O NOVO ELEMENTO: FILA VAZIA OU FILA COM ELEMENTOS
            if(fi->fim==NULL) //SE O CAMPO FIM DA MINHA FILA APONTAR PARA NULL, SIGNIFICA QUE MINHA FILA ESTARÁ VAZIA
            {
                fi->inicio=no;//ASSIM SENDO, O CAMPO INICIO APONTARÁ PARA O ELEMENTO NO (QUE ACABOU DE SER CRIADO)
            }
            else  //SE A MINHA FILA NAO FOR VAZIA...
            {
                fi->fim->prox=no;//A POSIÇÃO INICIAL DA MINHA FILA NAO SERÁ ALTERADA.
                //MAS O CAMPO PRÓXIMO, DO ELEMENTO QUE ESTAVA COMO ÚLTIMO, PASSARÁ A APONTAR PARA O ELEMENTO RECÉM CRIADO
            }
            fi->fim=no;//AQUI, O CAMPO FIM DA MINHA FILA APONTARÁ PARA O ELEMENTO CRIADO, OU SEJA, O ELEMENTO QUE SE TORNOU O ÚLTIMO DA FILA
            printf("\nELEMENTO INSERIDO\n");
        }
        else  //SE MINHA FILA NAO ESTIVER ALOCADA...
        {
            printf("\nERRO DE ALOCACAO\n");
        }
    }
}

//FUNÇAO QUE REMOVERÁ UM ELEMENTO DA FILA. VALE LEMBRAR QUE SÓ SERÃO REMOVIDOS ELEMENTOS:
//QUANDO A FILA NAO ESTIVER VAZIA; E SEMPRE REMOVERÁ O PRIMEIRO ELEMENTO (FIFO)

void remover(Fila *fi)
{
    if(fi==NULL) //SE A FILA NAO FOR ALOCADA...
    {
        printf("\nERRO DE ALOCACAO\n");
    }
    else  //FILA ALOCADA...
    {
        if(fi->inicio==NULL) //SE O CAMPO INÍCIO APONTAR PARA NULL, SIGNIFICA QUE A FILA ESTÁ VAZIA
        {
            printf("\nFILA VAZIA\n");
        }
        else  //SE NAO ESTIVER VAZIA...
        {
            Elem *no = fi->inicio;//CRIA-SE UM ELEMENTO AUXILIZAR QUE RECEBE O ENDEREÇO DO PRIMEIRO ELEMENTO DA FILA
            fi->inicio = fi->inicio->prox;//NESTE PONTO, O CAMPO INÍCIO DA FILA (O NÓ)
            //RECEBERÁ O ENDEREÇO DO PRÓXIMO ELEMENTO (O ELEMENTO QUE ESTARÁ NA SEGUNDA POSIÇÃO DA FILA)

            if(fi->inicio== NULL) //AQUI, SERÁ TESTADO SE O PRÓXIMO ELEMENTO NAO SERÁ NULL.
            {
                //SE ELE FOR NULL, SIGNIFICA QUE A MINHA FILA TINHA APENAS 1 ELEMENTO E, APÓS A EXCLUSÃO FICARÁ VAZIA
                fi->fim= NULL;//COMO A FILA FICARÁ VAZIA, O CAMPO FIM (DA FILA) APONTARÁ PARA NULL.
            }
            free(no);//NESTE PONTO, O ESPAÇO ALOCADO PARA O PRIMEOR ELEMENTO SERÁ LIBERADO
            //LEMBRE-SE, COMO ESTAMOS TRABALHANDO COM ENDEREÇO DE MEMÓRIA, O APONTADOR NO TEM O MESMO ENDEREÇO DO ANTIGO
            //PRIMEIRO ELEMENTO. PORTANTO, LIBERAR O ENDEREÇO NO, SERÁ O MESMO QUE LIBERAR O ESPAÇO DO ANTIGO PRIMEIRO ELEMENTO
            printf("\nELEMENTO REMOVIDO\n");
        }
    }
}

//FUNÇÃO QUE APRESENTARÁ OS ALUNOS ARMAZENADOS NA FILA
void mostrar(Fila *fi)
{
    if(fi == NULL)  //SE A FILA NAO FOR ALOCADA....
    {
        printf("\nERRO DE ALOCACAO\n");
    }
    else    //FILA ALOCADA...
    {
        if(fi->fim==NULL)  //SE O CAMPO FIM FOR IGUAL NULL, A FILA ESTARÁ VAZIA. PODERIA TESTAR TAMBÉM A POSIÇÃO INICIAL. TANTO FAZ...
        {
            printf("\nFILA VAZIA\n");
        }
        else    //HÁ ELEMENTO NA FILA
        {
            Elem* no = fi->inicio;//CRIA-SE UM ELEMENTO AUXILIAR PARA PERCORRER A FILA. RECERÁ O ENDEREÇO DO PRIMEIRO ELEMENTO DA FILA
            while(no != NULL)
            {
                printf("MATRICULA: %d\n",no->dados.mat);//APRESENTA A MATRICULA DO ALUNO
                printf("NOME: %s\n",no->dados.nome);//APRESENTA O NOME DO ALUNO
                printf("NOTAS: %.2f %.2f\n",no->dados.n1, no->dados.n2);//AS NOTAS 1 E 2 DO ALUNO
                printf("-------------------------------\n");//IMPRIME UMA LINHA DIVISÓRIA
                no = no->prox;//O ELEMENTO AUXILIAR RECEBE O ENDEREÇO DO PRÓXIMO ELEMENTO
            }//SE ELE FOR DIFERENTE DE NULL, SIGNIFICA QUE HÁ ELEMENTO NA FILA. O PROCESSO DE IMPRESSÃO SE REPETE
        }
    }
}

//FUNÇÃO DE MENU QUE RETONA A OPÇÃO ESCOLHIDA
int menu()
{
    int op;
    printf("\n0 - SAIR\n");
    printf("1 - MOSTRAR FILA\n");
    printf("2 - VERIFICAR FILA VAZIA\n");
    printf("3 - INSERIR\n");
    printf("4 - REMOVER\n");
    printf("\nOPCAO: ");
    scanf("%d",&op);
    putchar('\n');
    return op;//INTEIRO COM A OPÇÃO ESCOLHIDA
}

//FUNÇÃO QUE IRÁ LER OS DADOS DO ALUNO E ARMAZENARÁ NA STRUCT ALUNO

void novoAluno(struct aluno *al) //RECEBE COMO PARÂMETRO O ENDEREÇO DA ESTRUTURA ALUNO
{
    printf("DIGITE A MATRICULA: ");
    scanf("%d",&al->mat);//ADICIONA O CONTEÚDO AO CAMPO MATRICULA
    printf("DIGITE NOME: ");
    fflush(stdin);//LIMPA O BUFFER DO TECLADO (COMANDO PARA WINDOWS)
    gets(al->nome);//ADICIONA O CONTEÚDO AO CAMPO NOME
    printf("DIGITE A NOTA 1: ");
    scanf("%f",&al->n1);//ADICIONA O CONTEÚDO AO CAMPO NOTA 1
    printf("DIGITE A NOTA 2: ");
    scanf("%f",&al->n2);//ADICIONA O CONTEÚDO AO CAMPO NOTA 2
}

//FUNÇÃO MAIN..
main()
{
    int o;//VARIAVEL PARA RECEBER A OPÇÃO DIGITADA PELO USUÁRIO
    Fila *fi = criar();//CRIA UM PONTEIRO PARA FILA, QUE RECEBE O ENDEREÇO DA FILA RETORNADO PELA FUNÇÃO CRIAR();
    //O "TIPO" DO PONTEIRO SERÁ UMA ESTRUTURA: STRUCT FILA.
    struct aluno al;//CRIA UMA ESTRUTURA DO "TIPO" STRUCT ALUNO.
    while((o=menu())!=0)
    {
        switch(o)
        {
        case 0://OPCAO PARA TERMINAR O LAÇO E SAIR DO PROGRAMA
            break;
        case 1://OPÇÃO QUE MOSTRA OS ELEMENTOS DA FILA
            mostrar(fi);//CHAMA A FUNÇÃO MOSTRAR. PARÂMETRO: ENDEREÇO DA FILA CRIADA (FI É UM PONTEIRO)
            break;
        case 2:
            vazia(fi);//OPÇÃO EU VERIFICA SE A FILA ESTÁ VAZIA.PARÂMETRO: ENDEREÇO DA FILA CRIADA
            break;
        case 3:
            novoAluno(&al);//CHAMA A FUNÇÃO QUE LER OS CAMPOS DA ESTRUTURA ALUNO. (VEJA QUE SERÁ PASSADO O ENDEREÇO DA ESTRUTURA CRIADA)
            inserir(fi,al);//CHAMA A FUNÇÃO QUE INSERE UM ELEMENTO NA FILA. PARÂMENTROS: ENDEREÇO DA FILA CRIADA E OS DADOS DE ALUNOS RECEM DIGITADOS
            break;
        case 4://OPÇÃO PARA REMOÇÃO DO PRIMEIRO ELEMENTO DA FILA.
            remover(fi);//CHAMA A FUNÇÃO DE REMOÇAO. PARÂMETRO: ENDEREÇO DA FILA CRIADA
            break;
        default:
            printf("OPCAO INVALIDA\n\n");
        }
    }
    liberar(fi); //APÓS SAIR DO LAÇO, SERÁ CHAMADA A FUNÇÃO QUE DESALOCA O ESPAÇO DE MEMÓRIA PARA FILA.
}
